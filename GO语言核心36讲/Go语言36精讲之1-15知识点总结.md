## go语言知识点解析1-15

### GO语言的类型推断可以带来哪些好处?

所谓的类型推断就是定义变量的时候不指定变量的类型，让语言自己去推断出相应的类型比如

```sh
a :="124"
```
+ 程序的灵活性明显提高，使得代码重构变得更加容易 如将一个函数赋值给变量，在函数内部可以随意的修改代码

### 类型转换规则中值得注意的地方

+ 对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就合法

```sh
var srcInt = int16(-255)
dstInt := int8(srcInt)
```

如上的代码段，把大的转换到小的类型时，输出为1： 整数在计算机中都是以补码的形式存储，比如int16的值-255的补码是1111111100000001。如果我们把该值转换为int8类型的值，那么Go语言会把在较高位置（或者说最左边位置）上的8位二进制数直接截掉，从而得到00000001，又由于其最左边一位是0，表示它是个正整数，以及正整数的补码就等于其原码，所以dstInt的值就是1。

类似的：浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉

+ 当需要把整数值转换为一个string类型的值得时候，被转换的整数值应该可以代表一个有效的Unicode代码点，否则就变成�。

+ string类型与各种切片类型之间的互转，包括byte 和rune 类型等

### 别名类型与潜在类型

```sh
type MyString = string
type MyString2 string // 注意，这里没有等号。
```

这两个的区别是：第一行中：MyString是string类型的别名类型，他们是完全相同的，第二行中MyString2和string就是两个不同的类型，

所谓的潜在类型：就是某个类型的本质是哪个类型

潜在类型相同的不同类型的值之间是可以进行类型转换的。

### 引用类型与值类型

Go语言中的切片，字典，通道，函数类型都是引用类型；基础数据类型，结构体类型，数组都是值类型。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多

### 切片的长度与容量

一个切片的容量可以背看做是透过这个窗口最多可以看到的底层数组中元素的个数

```sh
s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
s4 := s3[3:6]
fmt.Printf("The length of s4: %d\n", len(s4))
fmt.Printf("The capacity of s4: %d\n", cap(s4))
fmt.Printf("The value of s4: %d\n", s4)
```

分析：由于s4是通过s3上施加切片操作得来的，所以s3的底层数据就是s4的底层数组，又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾，所以s4的容量就是其底层数组的长度8前去上述切片表达式中的那个其实索引3即5

切片的窗口向右扩展到最大的方法：s4[0:cap(s4)]

切片容量的增长：一般情况下，可以简单的认为新切片的容量将会是原切片容量的2倍，但当原切片的长度大于或等于1024时，Go语言将会以原容量的1.25倍作为新容量的基准。具体算法可通过runtime包中的slice.go文件中的growslice及相关函数查看

切片的底层数组什么时候被替换：一个切片的底层数组永远不会被替换，虽然在扩容的时候Go语言一定会生成新的底层数组，但是它也同时生成了新的切片。它只是把新的欺骗作为了新底层数据的窗口，而没有对远切片，及其底层数组做任何改动。在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。

### container包中的ring和list区别

ring 是一个循环链表，list是一个链表

+ ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示

+ 一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表了一个完整的链表

+ 创建并初始化一个Ring值得时候，可以指定它包含的元素数量，但对于一个List值来说缺不能这么做。循环链表一旦被创建，其长度是不可变的，

+ 通过var r ring.Ring 声明的变量是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表。

+ Ring值得len方法算法复杂度是O(N),List的len方法算法复杂度则是O(1)

### 字典中的键类型受到什么约束，哪些类型优先作为键类型

键类型必须是可以判断相等的类型，原因在于字典的本质是一个哈希表的特定实现。系统会对文中的键做哈希转换，后存入哈希表中。
查找过程：首先将key进行哈希，去哈希桶里去寻找，找到了之后，还要用原数据进行一次相等判断，这里的原因是存在哈希碰撞，两个不同的key生成的哈希值有可能相同。

求哈希和判等操作的速度越快，对应的类型就越适合作为键类型，优先选用数值类型和指针类型，通常情况下类型的宽度越小越好

### 对通道的发送和接收操作都有哪些基本的特性

+ 对同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
	对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的，例如，虽然会出现，正在被复制进通道但还未复制完成的元素之，但是他这是绝不会被想接收它的一方看到和取走

+ 发送操作和接收操作中对元素值的处理都是不可分割的
	这里的不可分割意思是，他们处理元素值时都是一气呵成的，绝不会被打断，发送操作不会发生只复制了一部分的情况，接收也一样等

+ 发送操作在完全完成之前会被阻塞，接收操作也是如此
	一般情况下，发送操作包括了复制元素值和放置副本到通道内部两个步骤，在这两个步骤完成之前，发起这个发送操作的那句代码会一直阻塞在那里。
	一般情况下，接收操作通常包含了复制通道内的元素之，放置副本到接收方，删掉原值，在这几个步骤完成之前，代码也会一直阻塞在那里

### 通道的长时间阻塞

对缓冲通道：当通道内满了之后，再发送数据会阻塞，在通道为空的情况下，接收数据会阻塞
对非缓冲通道：无论发送还是接收都会被阻塞，直到配对的操作开始执行了，相当于同步方式传递数据

特别说明：对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态

### 对通道操作引起恐慌

+ 对已关闭的通道发送操作
+ 对已关闭的通道再次关闭

### 单向通道的意义

在初始化通道的时候添加相应的数据流向，即规定了通道为单向通道只能发送或者只能接受

```sh
var uselessChan = make(chan<- int, 1)
```

存在的意义：用来约束代码规范，多用在接口中 如下

```sh
type Notifier interface {
	SendInt(ch chan<- int)
}
```
在这个代码中定义了接口类型，接口中的SendInt方法只能接受一个只能接收数据的通道。这样就能起到约束代码规范的作用，而在实际使用中，我们可以传给他一个双向通道，GO语言会自动的将双向通道转换为函数所需的单向通道


### 从通道获取元素的常用方式

```sh
intChan2 :=make(chan string，10)
for elem := range intChan2 {
	fmt.Printf("The element in intChan2: %v\n", elem)
}
```
+ for语句会不断尝试从通道中取出元素，即使通道被关闭，也会取出所有剩余元素值之后再结束执行
+ 当通道中没有元素值时，会被阻塞在for关键字那一行，直到有元素可取为止
+ 如果通道值为nil，则会被永远阻塞在for关键字那一行


### 通道中的select语句的分支选择规则

+ 每个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式。或者其他的表达式
+ select语句包含的候选分支中的case表达式都会在在语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下。结合上面的规则，在select语句开始执行时候，排在最上面的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式，之后才是第二个候选分支，以此类推
+ 如果针对某个分支的表达式的操作处于阻塞状态，则求值是不成功的，会继续往下看其他的分支
+ 仅当所有的case表达式都被求值完毕后，才会开始选择候选分支。这时，他只会挑选满足选择条件的候选分支执行，如果都不满足则执行默认分支，如果没有默认分支，则进入阻塞状态，直到至少有一个候选分支满足选择条件为止。则被唤醒执行相应分支
+ 如果同时有多个候选分支满足选择条件，那么它会用一种伪随机的算法在这些分支中选择一个并执行
+ 一个select只能有一个默认分支，与默认分支的位置无关


### 函数类别

#### 如何编写高阶函数

高阶函数满足的条件：1.接受其他的函数作为参数传入，2.把其他的函数作为结果返回
只要满足其中一个特点，就可以说这个函数是高阶函数

#### 闭包
高阶函数另一个重要部分是闭包

一个函数中存在对外来标识符的引用，即是一个闭包，如下是一个例子

```sh
type operate func(x, y int) int

func genCalculator(op operate) calculateFunc {
	return func(x int, y int) (int, error) {
		if op == nil {
			return 0, errors.New("invalid operation")
		}
		return op(x, y), nil
	}
}
```
其中genCalculator函数只做了一件事，那就是定义一个匿名的、cakculateFunc类型的函数并把它作为结果值返回，而这个匿名函数就是一个闭包函数，它里面使用的变量op既不代表它的任何参数或结果也不是它自己声明的，而是定义它的genCalculator函数的参数，所以是一个自由变量，他在genCalculator函数被调用的时候确定的，

实现闭包的意义在于动态的生成了一部分的程序逻辑

#### 传入函数的那些参数值后来怎么样了

所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本

例子如下：
```sh
package main

import "fmt"

func main() {
	complexArray1 := [3][]string{
		[]string{"d", "e", "f"},
		[]string{"g", "h", "i"},
		[]string{"j", "k", "l"},
	}
	fmt.Printf("The array: %v\n", complexArray1)
	array2 := modifyArray(complexArray1)
	fmt.Printf("The modified array: %v\n", array2)
	fmt.Printf("The original array: %v\n", complexArray1)
}

func modifyArray(a [3][]string) [3][]string {
	a[1][1] = "o"
	return a
}
```
记住数组类型是值类型，而切片是引用类型，例子中会修改原类型的值 如果将modifyArray 中的a[1][1]那行 修改为a[1] = []string{"j", "k", "l"} 则不会修改原值。

### 结构体

#### 结构体中的值方法和指针方法区别

+ 值方法的接收者是该方法所属的那个类型值的一个副本，我们再该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本省是某个引用类型的别名类型；而指针方法的接收者，是该方法所属的那个基本类型值得指针值得一个副本，修改的话，一定会体现在原值上

+ 值类型的方法值包括所有值方法，而指针类型包含了值方法和指针方法

+ 基本类型和指针类型的方法集合是不同的

### 接口

#### 接口变量的值在什么情况下才真正为nil？

```sh
type Pet interface {
	Name() string
	Category() string
}

type Dog struct {
	name string // 名字。
}
var dog1 *Dog
fmt.Println("The first dog is nil. [wrap1]")
dog2 := dog1
fmt.Println("The second dog is nil. [wrap1]")
var pet Pet = dog2
if pet == nil {
	fmt.Println("The pet is nil. [wrap1]")
} else {
	fmt.Println("The pet is not nil. [wrap1]")
}

输出为：
The first dog is nil.
The second dog is nil.
The pet is not nil.
```

解析：当我们把dog2的值赋给变量pet的时候，dog2的值会先被复制，不过由于在这里它的值是nil，所以就没必要复制了，然后Go语言会用一个专用数据结构iface的市里包装这个dog2的值得副本，虽然被包装的动态值是nil，但是pet的值却不会是nil，因为这个动态值只是pet值得一部分。
我们把由字面量nil表示的值叫做无类型的nil，这是真正的nil，因为它的类型是nil的，虽然dog2的值是真正的nil，但当我们把这个变量赋给pet的时候，Go语言会把它的类型和值放在一起考了，也就是说Go语言识别出赋予pet的值是一个*Dog类型的nil，因此通过iface的实例包装后的产物肯定就不是nil了

### 指针

指针的不可寻址：取址对象只要包括不可变的、临时结果和不安全的，这三个关键字中的一个就是不可寻址的

通过unsafe.Pointer+ uintptr突破私有成员访问！，其中unsafe包要慎重使用


